// This file is auto-generated by @hey-api/openapi-ts

import { type Options, getAttachmentStats, downloadAttachment, disable2Fa, enable2Fa, login, logout, register, requestPasswordReset, resendVerification, resetPassword, setup2Fa, verifyEmail, identifyUser, sendMessage, getUserTickets, getUserOrganizations, createOrganization, findOrganizationsByEmailDomain, joinOrganization, getOrganization, acceptInvitation, classify, kbSuggest, redact, rewrite, suggestReply, suggestReplyStream, summarize, telemetry, translate, getOrganizationAnalytics, getAgentAnalytics, getCsatByAgent, getCsatByMacro, getKnowledgeBaseAnalytics, getMacroAnalytics, getSystemAnalytics, getTicketAnalytics, getTrendAnalytics, executeAutomationRules, listAutomationRules, createAutomationRule, deleteAutomationRule, getAutomationRule, updateAutomationRule, getAutomationStats, listEvents, createEvent, exportEvents, getEventStats, streamEvents, getEvent, inviteUser, listArticles, createArticle, deleteArticle, getArticle, updateArticle, getPublicArticles, searchPublicArticles, listMacros, createMacro, deleteMacroExperiment, updateMacroExperiment, getPopularMacros, renderMacroTemplate, deleteMacro, getMacro, updateMacro, listMacroExperiments, createMacroExperiment, listMacroVariants, createMacroVariant, deleteMacroVariant, updateMacroVariant, getMembers, removeMember, updateMembership, deleteMessage, getMessage, getEffectivePermissions, listAgents, heartbeat, listRoles, createRole, deleteRole, getRole, updateRole, assignRole, revokeRole, listRules, createRule, deleteRule, updateRule, workload, getAllOrganizationSettings, setOrganizationSetting, deleteOrganizationSetting, getOrganizationSetting, checkBreaches, listPolicies, createPolicy, updatePolicy, listSurveys, submitSurvey, getSurveyAnalytics, exportSurveys, deleteSurvey, getSurvey, updateSurvey, listTags, createTag, getPopularTags, deleteTag, getTag, updateTag, getTagWithTickets, listTickets, createTicket, bulkUpdateTickets, mergeTickets, listSavedViews, createSavedView, deleteTicket, getTicket, updateTicket, deleteDraft, getDraft, upsertDraft, getTicketHistory, releaseTicketLock, lockTicket, takeoverTicketLock, listTicketMessages, createMessage, getMessageCount, getLatestMessage, searchMessages, listMessageAttachments, uploadAttachments, deleteAttachment, removeTagsFromTicket, addTagsToTicket, listTyping, typingUpdate, listWebhooks, createWebhook, listWebhookEvents, sendWebhooks, getWebhookStats, deleteWebhook, getWebhook, updateWebhook, testWebhook, getPermissionsCatalog, listSessions, cleanupExpiredSessions, revokeAllSessions, getSessionStats, revokeSession, getSession, extendSession, deleteAccount, listApiKeys, createApiKey, deleteApiKey, getApiKey, revokeApiKey, getLoginAttempts, getLoginHistory, changePassword, getProfile, updateProfile } from '../sdk.gen';
import { queryOptions, type UseMutationOptions, type DefaultError, infiniteQueryOptions, type InfiniteData } from '@tanstack/react-query';
import type { GetAttachmentStatsData, DownloadAttachmentData, Disable2FaData, Disable2FaResponse, Enable2FaData, Enable2FaResponse, LoginData, LoginResponse, LogoutData, LogoutResponse, RegisterData, RegisterResponse2, RequestPasswordResetData, RequestPasswordResetResponse, ResendVerificationData, ResendVerificationResponse, ResetPasswordData, ResetPasswordResponse, Setup2FaData, Setup2FaResponse2, VerifyEmailData, VerifyEmailResponse, IdentifyUserData, IdentifyUserResponse, SendMessageData, SendMessageResponse, GetUserTicketsData, GetUserOrganizationsData, CreateOrganizationData, CreateOrganizationResponse, FindOrganizationsByEmailDomainData, JoinOrganizationData, JoinOrganizationResponse, GetOrganizationData, AcceptInvitationData, AcceptInvitationResponse, ClassifyData, ClassifyResponse, KbSuggestData, KbSuggestResponse, RedactData, RedactResponse, RewriteData, RewriteResponse, SuggestReplyData, SuggestReplyResponse, SuggestReplyStreamData, SuggestReplyStreamResponse, SummarizeData, SummarizeResponse, TelemetryData, TelemetryResponse, TranslateData, TranslateResponse, GetOrganizationAnalyticsData, GetAgentAnalyticsData, GetCsatByAgentData, GetCsatByMacroData, GetKnowledgeBaseAnalyticsData, GetMacroAnalyticsData, GetSystemAnalyticsData, GetTicketAnalyticsData, GetTrendAnalyticsData, ExecuteAutomationRulesData, ExecuteAutomationRulesResponse, ListAutomationRulesData, ListAutomationRulesResponse, CreateAutomationRuleData, CreateAutomationRuleResponse, DeleteAutomationRuleData, GetAutomationRuleData, UpdateAutomationRuleData, UpdateAutomationRuleResponse, GetAutomationStatsData, ListEventsData, ListEventsResponse, CreateEventData, CreateEventResponse, ExportEventsData, GetEventStatsData, StreamEventsData, GetEventData, InviteUserData, InviteUserResponse, ListArticlesData, ListArticlesResponse, CreateArticleData, CreateArticleResponse, DeleteArticleData, DeleteArticleResponse, GetArticleData, UpdateArticleData, UpdateArticleResponse, GetPublicArticlesData, GetPublicArticlesResponse, SearchPublicArticlesData, SearchPublicArticlesResponse, ListMacrosData, ListMacrosResponse, CreateMacroData, CreateMacroResponse, DeleteMacroExperimentData, DeleteMacroExperimentResponse, UpdateMacroExperimentData, UpdateMacroExperimentResponse, GetPopularMacrosData, RenderMacroTemplateData, RenderMacroTemplateResponse, DeleteMacroData, DeleteMacroResponse, GetMacroData, UpdateMacroData, UpdateMacroResponse, ListMacroExperimentsData, CreateMacroExperimentData, CreateMacroExperimentResponse, ListMacroVariantsData, CreateMacroVariantData, CreateMacroVariantResponse, DeleteMacroVariantData, DeleteMacroVariantResponse, UpdateMacroVariantData, UpdateMacroVariantResponse, GetMembersData, RemoveMemberData, RemoveMemberResponse, UpdateMembershipData, UpdateMembershipResponse, DeleteMessageData, DeleteMessageResponse, GetMessageData, GetEffectivePermissionsData, ListAgentsData, HeartbeatData, HeartbeatResponse, ListRolesData, CreateRoleData, CreateRoleResponse, DeleteRoleData, DeleteRoleResponse, GetRoleData, UpdateRoleData, UpdateRoleResponse, AssignRoleData, AssignRoleResponse, RevokeRoleData, RevokeRoleResponse, ListRulesData, CreateRuleData, CreateRuleResponse, DeleteRuleData, DeleteRuleResponse, UpdateRuleData, UpdateRuleResponse, WorkloadData, GetAllOrganizationSettingsData, SetOrganizationSettingData, SetOrganizationSettingResponse, DeleteOrganizationSettingData, DeleteOrganizationSettingResponse, GetOrganizationSettingData, CheckBreachesData, CheckBreachesResponse, ListPoliciesData, CreatePolicyData, CreatePolicyResponse, UpdatePolicyData, UpdatePolicyResponse, ListSurveysData, ListSurveysResponse, SubmitSurveyData, SubmitSurveyResponse, GetSurveyAnalyticsData, ExportSurveysData, ExportSurveysResponse, DeleteSurveyData, GetSurveyData, UpdateSurveyData, UpdateSurveyResponse, ListTagsData, ListTagsResponse, CreateTagData, CreateTagResponse, GetPopularTagsData, DeleteTagData, DeleteTagResponse, GetTagData, UpdateTagData, UpdateTagResponse, GetTagWithTicketsData, GetTagWithTicketsResponse, ListTicketsData, ListTicketsResponse, CreateTicketData, CreateTicketResponse, BulkUpdateTicketsData, MergeTicketsData, ListSavedViewsData, CreateSavedViewData, CreateSavedViewResponse, DeleteTicketData, DeleteTicketResponse, GetTicketData, UpdateTicketData, UpdateTicketResponse, DeleteDraftData, DeleteDraftResponse, GetDraftData, UpsertDraftData, UpsertDraftResponse, GetTicketHistoryData, ReleaseTicketLockData, ReleaseTicketLockResponse, LockTicketData, TakeoverTicketLockData, ListTicketMessagesData, ListTicketMessagesResponse, CreateMessageData, CreateMessageResponse, GetMessageCountData, GetLatestMessageData, SearchMessagesData, SearchMessagesResponse, ListMessageAttachmentsData, UploadAttachmentsData, UploadAttachmentsResponse, DeleteAttachmentData, DeleteAttachmentResponse, RemoveTagsFromTicketData, AddTagsToTicketData, ListTypingData, TypingUpdateData, TypingUpdateResponse, ListWebhooksData, ListWebhooksResponse, CreateWebhookData, CreateWebhookResponse, ListWebhookEventsData, SendWebhooksData, SendWebhooksResponse, GetWebhookStatsData, DeleteWebhookData, GetWebhookData, UpdateWebhookData, UpdateWebhookResponse, TestWebhookData, TestWebhookResponse, GetPermissionsCatalogData, ListSessionsData, CleanupExpiredSessionsData, RevokeAllSessionsData, GetSessionStatsData, RevokeSessionData, GetSessionData, ExtendSessionData, ExtendSessionResponse, DeleteAccountData, DeleteAccountResponse, ListApiKeysData, ListApiKeysResponse, CreateApiKeyData, CreateApiKeyResponse2, DeleteApiKeyData, DeleteApiKeyResponse, GetApiKeyData, RevokeApiKeyData, RevokeApiKeyResponse, GetLoginAttemptsData, GetLoginHistoryData, ChangePasswordData, ChangePasswordResponse, GetProfileData, UpdateProfileData, UpdateProfileResponse } from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? _heyApiClient).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const getAttachmentStatsQueryKey = (options?: Options<GetAttachmentStatsData>) => createQueryKey('getAttachmentStats', options);

export const getAttachmentStatsOptions = (options?: Options<GetAttachmentStatsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAttachmentStats({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAttachmentStatsQueryKey(options)
    });
};

export const downloadAttachmentQueryKey = (options: Options<DownloadAttachmentData>) => createQueryKey('downloadAttachment', options);

export const downloadAttachmentOptions = (options: Options<DownloadAttachmentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await downloadAttachment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: downloadAttachmentQueryKey(options)
    });
};

export const disable2FaQueryKey = (options?: Options<Disable2FaData>) => createQueryKey('disable2Fa', options);

export const disable2FaOptions = (options?: Options<Disable2FaData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await disable2Fa({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: disable2FaQueryKey(options)
    });
};

export const disable2FaMutation = (options?: Partial<Options<Disable2FaData>>): UseMutationOptions<Disable2FaResponse, DefaultError, Options<Disable2FaData>> => {
    const mutationOptions: UseMutationOptions<Disable2FaResponse, DefaultError, Options<Disable2FaData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await disable2Fa({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const enable2FaQueryKey = (options: Options<Enable2FaData>) => createQueryKey('enable2Fa', options);

export const enable2FaOptions = (options: Options<Enable2FaData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await enable2Fa({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: enable2FaQueryKey(options)
    });
};

export const enable2FaMutation = (options?: Partial<Options<Enable2FaData>>): UseMutationOptions<Enable2FaResponse, DefaultError, Options<Enable2FaData>> => {
    const mutationOptions: UseMutationOptions<Enable2FaResponse, DefaultError, Options<Enable2FaData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await enable2Fa({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const loginQueryKey = (options: Options<LoginData>) => createQueryKey('login', options);

export const loginOptions = (options: Options<LoginData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await login({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: loginQueryKey(options)
    });
};

export const loginMutation = (options?: Partial<Options<LoginData>>): UseMutationOptions<LoginResponse, DefaultError, Options<LoginData>> => {
    const mutationOptions: UseMutationOptions<LoginResponse, DefaultError, Options<LoginData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await login({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const logoutQueryKey = (options?: Options<LogoutData>) => createQueryKey('logout', options);

export const logoutOptions = (options?: Options<LogoutData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await logout({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: logoutQueryKey(options)
    });
};

export const logoutMutation = (options?: Partial<Options<LogoutData>>): UseMutationOptions<LogoutResponse, DefaultError, Options<LogoutData>> => {
    const mutationOptions: UseMutationOptions<LogoutResponse, DefaultError, Options<LogoutData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await logout({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const registerQueryKey = (options: Options<RegisterData>) => createQueryKey('register', options);

export const registerOptions = (options: Options<RegisterData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await register({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: registerQueryKey(options)
    });
};

export const registerMutation = (options?: Partial<Options<RegisterData>>): UseMutationOptions<RegisterResponse2, DefaultError, Options<RegisterData>> => {
    const mutationOptions: UseMutationOptions<RegisterResponse2, DefaultError, Options<RegisterData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await register({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const requestPasswordResetQueryKey = (options: Options<RequestPasswordResetData>) => createQueryKey('requestPasswordReset', options);

export const requestPasswordResetOptions = (options: Options<RequestPasswordResetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await requestPasswordReset({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: requestPasswordResetQueryKey(options)
    });
};

export const requestPasswordResetMutation = (options?: Partial<Options<RequestPasswordResetData>>): UseMutationOptions<RequestPasswordResetResponse, DefaultError, Options<RequestPasswordResetData>> => {
    const mutationOptions: UseMutationOptions<RequestPasswordResetResponse, DefaultError, Options<RequestPasswordResetData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await requestPasswordReset({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const resendVerificationQueryKey = (options: Options<ResendVerificationData>) => createQueryKey('resendVerification', options);

export const resendVerificationOptions = (options: Options<ResendVerificationData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await resendVerification({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: resendVerificationQueryKey(options)
    });
};

export const resendVerificationMutation = (options?: Partial<Options<ResendVerificationData>>): UseMutationOptions<ResendVerificationResponse, DefaultError, Options<ResendVerificationData>> => {
    const mutationOptions: UseMutationOptions<ResendVerificationResponse, DefaultError, Options<ResendVerificationData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await resendVerification({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const resetPasswordQueryKey = (options: Options<ResetPasswordData>) => createQueryKey('resetPassword', options);

export const resetPasswordOptions = (options: Options<ResetPasswordData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await resetPassword({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: resetPasswordQueryKey(options)
    });
};

export const resetPasswordMutation = (options?: Partial<Options<ResetPasswordData>>): UseMutationOptions<ResetPasswordResponse, DefaultError, Options<ResetPasswordData>> => {
    const mutationOptions: UseMutationOptions<ResetPasswordResponse, DefaultError, Options<ResetPasswordData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await resetPassword({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const setup2FaQueryKey = (options?: Options<Setup2FaData>) => createQueryKey('setup2Fa', options);

export const setup2FaOptions = (options?: Options<Setup2FaData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await setup2Fa({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: setup2FaQueryKey(options)
    });
};

export const setup2FaMutation = (options?: Partial<Options<Setup2FaData>>): UseMutationOptions<Setup2FaResponse2, DefaultError, Options<Setup2FaData>> => {
    const mutationOptions: UseMutationOptions<Setup2FaResponse2, DefaultError, Options<Setup2FaData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await setup2Fa({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const verifyEmailQueryKey = (options: Options<VerifyEmailData>) => createQueryKey('verifyEmail', options);

export const verifyEmailOptions = (options: Options<VerifyEmailData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await verifyEmail({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: verifyEmailQueryKey(options)
    });
};

export const verifyEmailMutation = (options?: Partial<Options<VerifyEmailData>>): UseMutationOptions<VerifyEmailResponse, DefaultError, Options<VerifyEmailData>> => {
    const mutationOptions: UseMutationOptions<VerifyEmailResponse, DefaultError, Options<VerifyEmailData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await verifyEmail({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const identifyUserQueryKey = (options: Options<IdentifyUserData>) => createQueryKey('identifyUser', options);

export const identifyUserOptions = (options: Options<IdentifyUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await identifyUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: identifyUserQueryKey(options)
    });
};

export const identifyUserMutation = (options?: Partial<Options<IdentifyUserData>>): UseMutationOptions<IdentifyUserResponse, DefaultError, Options<IdentifyUserData>> => {
    const mutationOptions: UseMutationOptions<IdentifyUserResponse, DefaultError, Options<IdentifyUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await identifyUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const sendMessageQueryKey = (options: Options<SendMessageData>) => createQueryKey('sendMessage', options);

export const sendMessageOptions = (options: Options<SendMessageData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await sendMessage({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: sendMessageQueryKey(options)
    });
};

export const sendMessageMutation = (options?: Partial<Options<SendMessageData>>): UseMutationOptions<SendMessageResponse, DefaultError, Options<SendMessageData>> => {
    const mutationOptions: UseMutationOptions<SendMessageResponse, DefaultError, Options<SendMessageData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await sendMessage({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserTicketsQueryKey = (options: Options<GetUserTicketsData>) => createQueryKey('getUserTickets', options);

export const getUserTicketsOptions = (options: Options<GetUserTicketsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserTickets({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserTicketsQueryKey(options)
    });
};

export const getUserOrganizationsQueryKey = (options?: Options<GetUserOrganizationsData>) => createQueryKey('getUserOrganizations', options);

export const getUserOrganizationsOptions = (options?: Options<GetUserOrganizationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserOrganizations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserOrganizationsQueryKey(options)
    });
};

export const createOrganizationQueryKey = (options: Options<CreateOrganizationData>) => createQueryKey('createOrganization', options);

export const createOrganizationOptions = (options: Options<CreateOrganizationData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createOrganization({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createOrganizationQueryKey(options)
    });
};

export const createOrganizationMutation = (options?: Partial<Options<CreateOrganizationData>>): UseMutationOptions<CreateOrganizationResponse, DefaultError, Options<CreateOrganizationData>> => {
    const mutationOptions: UseMutationOptions<CreateOrganizationResponse, DefaultError, Options<CreateOrganizationData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createOrganization({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const findOrganizationsByEmailDomainQueryKey = (options: Options<FindOrganizationsByEmailDomainData>) => createQueryKey('findOrganizationsByEmailDomain', options);

export const findOrganizationsByEmailDomainOptions = (options: Options<FindOrganizationsByEmailDomainData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await findOrganizationsByEmailDomain({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: findOrganizationsByEmailDomainQueryKey(options)
    });
};

export const joinOrganizationQueryKey = (options: Options<JoinOrganizationData>) => createQueryKey('joinOrganization', options);

export const joinOrganizationOptions = (options: Options<JoinOrganizationData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await joinOrganization({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: joinOrganizationQueryKey(options)
    });
};

export const joinOrganizationMutation = (options?: Partial<Options<JoinOrganizationData>>): UseMutationOptions<JoinOrganizationResponse, DefaultError, Options<JoinOrganizationData>> => {
    const mutationOptions: UseMutationOptions<JoinOrganizationResponse, DefaultError, Options<JoinOrganizationData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await joinOrganization({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getOrganizationQueryKey = (options: Options<GetOrganizationData>) => createQueryKey('getOrganization', options);

export const getOrganizationOptions = (options: Options<GetOrganizationData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getOrganization({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOrganizationQueryKey(options)
    });
};

export const acceptInvitationQueryKey = (options: Options<AcceptInvitationData>) => createQueryKey('acceptInvitation', options);

export const acceptInvitationOptions = (options: Options<AcceptInvitationData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await acceptInvitation({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: acceptInvitationQueryKey(options)
    });
};

export const acceptInvitationMutation = (options?: Partial<Options<AcceptInvitationData>>): UseMutationOptions<AcceptInvitationResponse, DefaultError, Options<AcceptInvitationData>> => {
    const mutationOptions: UseMutationOptions<AcceptInvitationResponse, DefaultError, Options<AcceptInvitationData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await acceptInvitation({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const classifyQueryKey = (options: Options<ClassifyData>) => createQueryKey('classify', options);

export const classifyOptions = (options: Options<ClassifyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await classify({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: classifyQueryKey(options)
    });
};

export const classifyMutation = (options?: Partial<Options<ClassifyData>>): UseMutationOptions<ClassifyResponse, DefaultError, Options<ClassifyData>> => {
    const mutationOptions: UseMutationOptions<ClassifyResponse, DefaultError, Options<ClassifyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await classify({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const kbSuggestQueryKey = (options: Options<KbSuggestData>) => createQueryKey('kbSuggest', options);

export const kbSuggestOptions = (options: Options<KbSuggestData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await kbSuggest({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: kbSuggestQueryKey(options)
    });
};

export const kbSuggestMutation = (options?: Partial<Options<KbSuggestData>>): UseMutationOptions<KbSuggestResponse, DefaultError, Options<KbSuggestData>> => {
    const mutationOptions: UseMutationOptions<KbSuggestResponse, DefaultError, Options<KbSuggestData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await kbSuggest({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const redactQueryKey = (options: Options<RedactData>) => createQueryKey('redact', options);

export const redactOptions = (options: Options<RedactData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await redact({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: redactQueryKey(options)
    });
};

export const redactMutation = (options?: Partial<Options<RedactData>>): UseMutationOptions<RedactResponse, DefaultError, Options<RedactData>> => {
    const mutationOptions: UseMutationOptions<RedactResponse, DefaultError, Options<RedactData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await redact({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const rewriteQueryKey = (options: Options<RewriteData>) => createQueryKey('rewrite', options);

export const rewriteOptions = (options: Options<RewriteData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await rewrite({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: rewriteQueryKey(options)
    });
};

export const rewriteMutation = (options?: Partial<Options<RewriteData>>): UseMutationOptions<RewriteResponse, DefaultError, Options<RewriteData>> => {
    const mutationOptions: UseMutationOptions<RewriteResponse, DefaultError, Options<RewriteData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await rewrite({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const suggestReplyQueryKey = (options: Options<SuggestReplyData>) => createQueryKey('suggestReply', options);

export const suggestReplyOptions = (options: Options<SuggestReplyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await suggestReply({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: suggestReplyQueryKey(options)
    });
};

export const suggestReplyMutation = (options?: Partial<Options<SuggestReplyData>>): UseMutationOptions<SuggestReplyResponse, DefaultError, Options<SuggestReplyData>> => {
    const mutationOptions: UseMutationOptions<SuggestReplyResponse, DefaultError, Options<SuggestReplyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await suggestReply({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const suggestReplyStreamQueryKey = (options: Options<SuggestReplyStreamData>) => createQueryKey('suggestReplyStream', options);

export const suggestReplyStreamOptions = (options: Options<SuggestReplyStreamData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await suggestReplyStream({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: suggestReplyStreamQueryKey(options)
    });
};

export const suggestReplyStreamMutation = (options?: Partial<Options<SuggestReplyStreamData>>): UseMutationOptions<SuggestReplyStreamResponse, DefaultError, Options<SuggestReplyStreamData>> => {
    const mutationOptions: UseMutationOptions<SuggestReplyStreamResponse, DefaultError, Options<SuggestReplyStreamData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await suggestReplyStream({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const summarizeQueryKey = (options: Options<SummarizeData>) => createQueryKey('summarize', options);

export const summarizeOptions = (options: Options<SummarizeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await summarize({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: summarizeQueryKey(options)
    });
};

export const summarizeMutation = (options?: Partial<Options<SummarizeData>>): UseMutationOptions<SummarizeResponse, DefaultError, Options<SummarizeData>> => {
    const mutationOptions: UseMutationOptions<SummarizeResponse, DefaultError, Options<SummarizeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await summarize({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const telemetryQueryKey = (options: Options<TelemetryData>) => createQueryKey('telemetry', options);

export const telemetryOptions = (options: Options<TelemetryData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await telemetry({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: telemetryQueryKey(options)
    });
};

export const telemetryMutation = (options?: Partial<Options<TelemetryData>>): UseMutationOptions<TelemetryResponse, DefaultError, Options<TelemetryData>> => {
    const mutationOptions: UseMutationOptions<TelemetryResponse, DefaultError, Options<TelemetryData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await telemetry({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const translateQueryKey = (options: Options<TranslateData>) => createQueryKey('translate', options);

export const translateOptions = (options: Options<TranslateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await translate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: translateQueryKey(options)
    });
};

export const translateMutation = (options?: Partial<Options<TranslateData>>): UseMutationOptions<TranslateResponse, DefaultError, Options<TranslateData>> => {
    const mutationOptions: UseMutationOptions<TranslateResponse, DefaultError, Options<TranslateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await translate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getOrganizationAnalyticsQueryKey = (options: Options<GetOrganizationAnalyticsData>) => createQueryKey('getOrganizationAnalytics', options);

export const getOrganizationAnalyticsOptions = (options: Options<GetOrganizationAnalyticsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getOrganizationAnalytics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOrganizationAnalyticsQueryKey(options)
    });
};

export const getAgentAnalyticsQueryKey = (options: Options<GetAgentAnalyticsData>) => createQueryKey('getAgentAnalytics', options);

export const getAgentAnalyticsOptions = (options: Options<GetAgentAnalyticsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAgentAnalytics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAgentAnalyticsQueryKey(options)
    });
};

export const getCsatByAgentQueryKey = (options: Options<GetCsatByAgentData>) => createQueryKey('getCsatByAgent', options);

export const getCsatByAgentOptions = (options: Options<GetCsatByAgentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCsatByAgent({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCsatByAgentQueryKey(options)
    });
};

export const getCsatByMacroQueryKey = (options: Options<GetCsatByMacroData>) => createQueryKey('getCsatByMacro', options);

export const getCsatByMacroOptions = (options: Options<GetCsatByMacroData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCsatByMacro({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCsatByMacroQueryKey(options)
    });
};

export const getKnowledgeBaseAnalyticsQueryKey = (options: Options<GetKnowledgeBaseAnalyticsData>) => createQueryKey('getKnowledgeBaseAnalytics', options);

export const getKnowledgeBaseAnalyticsOptions = (options: Options<GetKnowledgeBaseAnalyticsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getKnowledgeBaseAnalytics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getKnowledgeBaseAnalyticsQueryKey(options)
    });
};

export const getMacroAnalyticsQueryKey = (options: Options<GetMacroAnalyticsData>) => createQueryKey('getMacroAnalytics', options);

export const getMacroAnalyticsOptions = (options: Options<GetMacroAnalyticsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMacroAnalytics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMacroAnalyticsQueryKey(options)
    });
};

export const getSystemAnalyticsQueryKey = (options: Options<GetSystemAnalyticsData>) => createQueryKey('getSystemAnalytics', options);

export const getSystemAnalyticsOptions = (options: Options<GetSystemAnalyticsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSystemAnalytics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSystemAnalyticsQueryKey(options)
    });
};

export const getTicketAnalyticsQueryKey = (options: Options<GetTicketAnalyticsData>) => createQueryKey('getTicketAnalytics', options);

export const getTicketAnalyticsOptions = (options: Options<GetTicketAnalyticsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTicketAnalytics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTicketAnalyticsQueryKey(options)
    });
};

export const getTrendAnalyticsQueryKey = (options: Options<GetTrendAnalyticsData>) => createQueryKey('getTrendAnalytics', options);

export const getTrendAnalyticsOptions = (options: Options<GetTrendAnalyticsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTrendAnalytics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTrendAnalyticsQueryKey(options)
    });
};

export const executeAutomationRulesQueryKey = (options: Options<ExecuteAutomationRulesData>) => createQueryKey('executeAutomationRules', options);

export const executeAutomationRulesOptions = (options: Options<ExecuteAutomationRulesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await executeAutomationRules({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: executeAutomationRulesQueryKey(options)
    });
};

export const executeAutomationRulesMutation = (options?: Partial<Options<ExecuteAutomationRulesData>>): UseMutationOptions<ExecuteAutomationRulesResponse, DefaultError, Options<ExecuteAutomationRulesData>> => {
    const mutationOptions: UseMutationOptions<ExecuteAutomationRulesResponse, DefaultError, Options<ExecuteAutomationRulesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await executeAutomationRules({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listAutomationRulesQueryKey = (options: Options<ListAutomationRulesData>) => createQueryKey('listAutomationRules', options);

export const listAutomationRulesOptions = (options: Options<ListAutomationRulesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listAutomationRules({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listAutomationRulesQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = {
        ...queryKey[0]
    };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const listAutomationRulesInfiniteQueryKey = (options: Options<ListAutomationRulesData>): QueryKey<Options<ListAutomationRulesData>> => createQueryKey('listAutomationRules', options, true);

export const listAutomationRulesInfiniteOptions = (options: Options<ListAutomationRulesData>) => {
    return infiniteQueryOptions<ListAutomationRulesResponse, DefaultError, InfiniteData<ListAutomationRulesResponse>, QueryKey<Options<ListAutomationRulesData>>, number | Pick<QueryKey<Options<ListAutomationRulesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListAutomationRulesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listAutomationRules({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listAutomationRulesInfiniteQueryKey(options)
    });
};

export const createAutomationRuleQueryKey = (options: Options<CreateAutomationRuleData>) => createQueryKey('createAutomationRule', options);

export const createAutomationRuleOptions = (options: Options<CreateAutomationRuleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createAutomationRule({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createAutomationRuleQueryKey(options)
    });
};

export const createAutomationRuleMutation = (options?: Partial<Options<CreateAutomationRuleData>>): UseMutationOptions<CreateAutomationRuleResponse, DefaultError, Options<CreateAutomationRuleData>> => {
    const mutationOptions: UseMutationOptions<CreateAutomationRuleResponse, DefaultError, Options<CreateAutomationRuleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createAutomationRule({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteAutomationRuleMutation = (options?: Partial<Options<DeleteAutomationRuleData>>): UseMutationOptions<unknown, DefaultError, Options<DeleteAutomationRuleData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DeleteAutomationRuleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteAutomationRule({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAutomationRuleQueryKey = (options: Options<GetAutomationRuleData>) => createQueryKey('getAutomationRule', options);

export const getAutomationRuleOptions = (options: Options<GetAutomationRuleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAutomationRule({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAutomationRuleQueryKey(options)
    });
};

export const updateAutomationRuleMutation = (options?: Partial<Options<UpdateAutomationRuleData>>): UseMutationOptions<UpdateAutomationRuleResponse, DefaultError, Options<UpdateAutomationRuleData>> => {
    const mutationOptions: UseMutationOptions<UpdateAutomationRuleResponse, DefaultError, Options<UpdateAutomationRuleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateAutomationRule({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAutomationStatsQueryKey = (options: Options<GetAutomationStatsData>) => createQueryKey('getAutomationStats', options);

export const getAutomationStatsOptions = (options: Options<GetAutomationStatsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAutomationStats({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAutomationStatsQueryKey(options)
    });
};

export const listEventsQueryKey = (options: Options<ListEventsData>) => createQueryKey('listEvents', options);

export const listEventsOptions = (options: Options<ListEventsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listEvents({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listEventsQueryKey(options)
    });
};

export const listEventsInfiniteQueryKey = (options: Options<ListEventsData>): QueryKey<Options<ListEventsData>> => createQueryKey('listEvents', options, true);

export const listEventsInfiniteOptions = (options: Options<ListEventsData>) => {
    return infiniteQueryOptions<ListEventsResponse, DefaultError, InfiniteData<ListEventsResponse>, QueryKey<Options<ListEventsData>>, number | Pick<QueryKey<Options<ListEventsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListEventsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listEvents({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listEventsInfiniteQueryKey(options)
    });
};

export const createEventQueryKey = (options: Options<CreateEventData>) => createQueryKey('createEvent', options);

export const createEventOptions = (options: Options<CreateEventData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createEvent({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createEventQueryKey(options)
    });
};

export const createEventMutation = (options?: Partial<Options<CreateEventData>>): UseMutationOptions<CreateEventResponse, DefaultError, Options<CreateEventData>> => {
    const mutationOptions: UseMutationOptions<CreateEventResponse, DefaultError, Options<CreateEventData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createEvent({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const exportEventsQueryKey = (options: Options<ExportEventsData>) => createQueryKey('exportEvents', options);

export const exportEventsOptions = (options: Options<ExportEventsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await exportEvents({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: exportEventsQueryKey(options)
    });
};

export const getEventStatsQueryKey = (options: Options<GetEventStatsData>) => createQueryKey('getEventStats', options);

export const getEventStatsOptions = (options: Options<GetEventStatsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEventStats({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getEventStatsQueryKey(options)
    });
};

export const streamEventsQueryKey = (options: Options<StreamEventsData>) => createQueryKey('streamEvents', options);

export const streamEventsOptions = (options: Options<StreamEventsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await streamEvents({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: streamEventsQueryKey(options)
    });
};

export const getEventQueryKey = (options: Options<GetEventData>) => createQueryKey('getEvent', options);

export const getEventOptions = (options: Options<GetEventData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEvent({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getEventQueryKey(options)
    });
};

export const inviteUserQueryKey = (options: Options<InviteUserData>) => createQueryKey('inviteUser', options);

export const inviteUserOptions = (options: Options<InviteUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await inviteUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: inviteUserQueryKey(options)
    });
};

export const inviteUserMutation = (options?: Partial<Options<InviteUserData>>): UseMutationOptions<InviteUserResponse, DefaultError, Options<InviteUserData>> => {
    const mutationOptions: UseMutationOptions<InviteUserResponse, DefaultError, Options<InviteUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await inviteUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listArticlesQueryKey = (options: Options<ListArticlesData>) => createQueryKey('listArticles', options);

export const listArticlesOptions = (options: Options<ListArticlesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listArticles({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listArticlesQueryKey(options)
    });
};

export const listArticlesInfiniteQueryKey = (options: Options<ListArticlesData>): QueryKey<Options<ListArticlesData>> => createQueryKey('listArticles', options, true);

export const listArticlesInfiniteOptions = (options: Options<ListArticlesData>) => {
    return infiniteQueryOptions<ListArticlesResponse, DefaultError, InfiniteData<ListArticlesResponse>, QueryKey<Options<ListArticlesData>>, number | Pick<QueryKey<Options<ListArticlesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListArticlesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listArticles({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listArticlesInfiniteQueryKey(options)
    });
};

export const createArticleQueryKey = (options: Options<CreateArticleData>) => createQueryKey('createArticle', options);

export const createArticleOptions = (options: Options<CreateArticleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createArticle({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createArticleQueryKey(options)
    });
};

export const createArticleMutation = (options?: Partial<Options<CreateArticleData>>): UseMutationOptions<CreateArticleResponse, DefaultError, Options<CreateArticleData>> => {
    const mutationOptions: UseMutationOptions<CreateArticleResponse, DefaultError, Options<CreateArticleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createArticle({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteArticleMutation = (options?: Partial<Options<DeleteArticleData>>): UseMutationOptions<DeleteArticleResponse, DefaultError, Options<DeleteArticleData>> => {
    const mutationOptions: UseMutationOptions<DeleteArticleResponse, DefaultError, Options<DeleteArticleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteArticle({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getArticleQueryKey = (options: Options<GetArticleData>) => createQueryKey('getArticle', options);

export const getArticleOptions = (options: Options<GetArticleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getArticle({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getArticleQueryKey(options)
    });
};

export const updateArticleMutation = (options?: Partial<Options<UpdateArticleData>>): UseMutationOptions<UpdateArticleResponse, DefaultError, Options<UpdateArticleData>> => {
    const mutationOptions: UseMutationOptions<UpdateArticleResponse, DefaultError, Options<UpdateArticleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateArticle({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPublicArticlesQueryKey = (options: Options<GetPublicArticlesData>) => createQueryKey('getPublicArticles', options);

export const getPublicArticlesOptions = (options: Options<GetPublicArticlesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPublicArticles({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPublicArticlesQueryKey(options)
    });
};

export const getPublicArticlesInfiniteQueryKey = (options: Options<GetPublicArticlesData>): QueryKey<Options<GetPublicArticlesData>> => createQueryKey('getPublicArticles', options, true);

export const getPublicArticlesInfiniteOptions = (options: Options<GetPublicArticlesData>) => {
    return infiniteQueryOptions<GetPublicArticlesResponse, DefaultError, InfiniteData<GetPublicArticlesResponse>, QueryKey<Options<GetPublicArticlesData>>, number | Pick<QueryKey<Options<GetPublicArticlesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetPublicArticlesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getPublicArticles({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPublicArticlesInfiniteQueryKey(options)
    });
};

export const searchPublicArticlesQueryKey = (options: Options<SearchPublicArticlesData>) => createQueryKey('searchPublicArticles', options);

export const searchPublicArticlesOptions = (options: Options<SearchPublicArticlesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await searchPublicArticles({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: searchPublicArticlesQueryKey(options)
    });
};

export const searchPublicArticlesInfiniteQueryKey = (options: Options<SearchPublicArticlesData>): QueryKey<Options<SearchPublicArticlesData>> => createQueryKey('searchPublicArticles', options, true);

export const searchPublicArticlesInfiniteOptions = (options: Options<SearchPublicArticlesData>) => {
    return infiniteQueryOptions<SearchPublicArticlesResponse, DefaultError, InfiniteData<SearchPublicArticlesResponse>, QueryKey<Options<SearchPublicArticlesData>>, number | Pick<QueryKey<Options<SearchPublicArticlesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<SearchPublicArticlesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await searchPublicArticles({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: searchPublicArticlesInfiniteQueryKey(options)
    });
};

export const listMacrosQueryKey = (options: Options<ListMacrosData>) => createQueryKey('listMacros', options);

export const listMacrosOptions = (options: Options<ListMacrosData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listMacros({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listMacrosQueryKey(options)
    });
};

export const listMacrosInfiniteQueryKey = (options: Options<ListMacrosData>): QueryKey<Options<ListMacrosData>> => createQueryKey('listMacros', options, true);

export const listMacrosInfiniteOptions = (options: Options<ListMacrosData>) => {
    return infiniteQueryOptions<ListMacrosResponse, DefaultError, InfiniteData<ListMacrosResponse>, QueryKey<Options<ListMacrosData>>, number | Pick<QueryKey<Options<ListMacrosData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListMacrosData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listMacros({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listMacrosInfiniteQueryKey(options)
    });
};

export const createMacroQueryKey = (options: Options<CreateMacroData>) => createQueryKey('createMacro', options);

export const createMacroOptions = (options: Options<CreateMacroData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createMacro({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createMacroQueryKey(options)
    });
};

export const createMacroMutation = (options?: Partial<Options<CreateMacroData>>): UseMutationOptions<CreateMacroResponse, DefaultError, Options<CreateMacroData>> => {
    const mutationOptions: UseMutationOptions<CreateMacroResponse, DefaultError, Options<CreateMacroData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createMacro({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteMacroExperimentMutation = (options?: Partial<Options<DeleteMacroExperimentData>>): UseMutationOptions<DeleteMacroExperimentResponse, DefaultError, Options<DeleteMacroExperimentData>> => {
    const mutationOptions: UseMutationOptions<DeleteMacroExperimentResponse, DefaultError, Options<DeleteMacroExperimentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteMacroExperiment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updateMacroExperimentMutation = (options?: Partial<Options<UpdateMacroExperimentData>>): UseMutationOptions<UpdateMacroExperimentResponse, DefaultError, Options<UpdateMacroExperimentData>> => {
    const mutationOptions: UseMutationOptions<UpdateMacroExperimentResponse, DefaultError, Options<UpdateMacroExperimentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateMacroExperiment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPopularMacrosQueryKey = (options: Options<GetPopularMacrosData>) => createQueryKey('getPopularMacros', options);

export const getPopularMacrosOptions = (options: Options<GetPopularMacrosData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPopularMacros({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPopularMacrosQueryKey(options)
    });
};

export const renderMacroTemplateQueryKey = (options: Options<RenderMacroTemplateData>) => createQueryKey('renderMacroTemplate', options);

export const renderMacroTemplateOptions = (options: Options<RenderMacroTemplateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await renderMacroTemplate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: renderMacroTemplateQueryKey(options)
    });
};

export const renderMacroTemplateMutation = (options?: Partial<Options<RenderMacroTemplateData>>): UseMutationOptions<RenderMacroTemplateResponse, DefaultError, Options<RenderMacroTemplateData>> => {
    const mutationOptions: UseMutationOptions<RenderMacroTemplateResponse, DefaultError, Options<RenderMacroTemplateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await renderMacroTemplate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteMacroMutation = (options?: Partial<Options<DeleteMacroData>>): UseMutationOptions<DeleteMacroResponse, DefaultError, Options<DeleteMacroData>> => {
    const mutationOptions: UseMutationOptions<DeleteMacroResponse, DefaultError, Options<DeleteMacroData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteMacro({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMacroQueryKey = (options: Options<GetMacroData>) => createQueryKey('getMacro', options);

export const getMacroOptions = (options: Options<GetMacroData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMacro({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMacroQueryKey(options)
    });
};

export const updateMacroMutation = (options?: Partial<Options<UpdateMacroData>>): UseMutationOptions<UpdateMacroResponse, DefaultError, Options<UpdateMacroData>> => {
    const mutationOptions: UseMutationOptions<UpdateMacroResponse, DefaultError, Options<UpdateMacroData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateMacro({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listMacroExperimentsQueryKey = (options: Options<ListMacroExperimentsData>) => createQueryKey('listMacroExperiments', options);

export const listMacroExperimentsOptions = (options: Options<ListMacroExperimentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listMacroExperiments({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listMacroExperimentsQueryKey(options)
    });
};

export const createMacroExperimentQueryKey = (options: Options<CreateMacroExperimentData>) => createQueryKey('createMacroExperiment', options);

export const createMacroExperimentOptions = (options: Options<CreateMacroExperimentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createMacroExperiment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createMacroExperimentQueryKey(options)
    });
};

export const createMacroExperimentMutation = (options?: Partial<Options<CreateMacroExperimentData>>): UseMutationOptions<CreateMacroExperimentResponse, DefaultError, Options<CreateMacroExperimentData>> => {
    const mutationOptions: UseMutationOptions<CreateMacroExperimentResponse, DefaultError, Options<CreateMacroExperimentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createMacroExperiment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listMacroVariantsQueryKey = (options: Options<ListMacroVariantsData>) => createQueryKey('listMacroVariants', options);

export const listMacroVariantsOptions = (options: Options<ListMacroVariantsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listMacroVariants({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listMacroVariantsQueryKey(options)
    });
};

export const createMacroVariantQueryKey = (options: Options<CreateMacroVariantData>) => createQueryKey('createMacroVariant', options);

export const createMacroVariantOptions = (options: Options<CreateMacroVariantData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createMacroVariant({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createMacroVariantQueryKey(options)
    });
};

export const createMacroVariantMutation = (options?: Partial<Options<CreateMacroVariantData>>): UseMutationOptions<CreateMacroVariantResponse, DefaultError, Options<CreateMacroVariantData>> => {
    const mutationOptions: UseMutationOptions<CreateMacroVariantResponse, DefaultError, Options<CreateMacroVariantData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createMacroVariant({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteMacroVariantMutation = (options?: Partial<Options<DeleteMacroVariantData>>): UseMutationOptions<DeleteMacroVariantResponse, DefaultError, Options<DeleteMacroVariantData>> => {
    const mutationOptions: UseMutationOptions<DeleteMacroVariantResponse, DefaultError, Options<DeleteMacroVariantData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteMacroVariant({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updateMacroVariantMutation = (options?: Partial<Options<UpdateMacroVariantData>>): UseMutationOptions<UpdateMacroVariantResponse, DefaultError, Options<UpdateMacroVariantData>> => {
    const mutationOptions: UseMutationOptions<UpdateMacroVariantResponse, DefaultError, Options<UpdateMacroVariantData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateMacroVariant({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMembersQueryKey = (options: Options<GetMembersData>) => createQueryKey('getMembers', options);

export const getMembersOptions = (options: Options<GetMembersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMembers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMembersQueryKey(options)
    });
};

export const removeMemberMutation = (options?: Partial<Options<RemoveMemberData>>): UseMutationOptions<RemoveMemberResponse, DefaultError, Options<RemoveMemberData>> => {
    const mutationOptions: UseMutationOptions<RemoveMemberResponse, DefaultError, Options<RemoveMemberData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeMember({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updateMembershipMutation = (options?: Partial<Options<UpdateMembershipData>>): UseMutationOptions<UpdateMembershipResponse, DefaultError, Options<UpdateMembershipData>> => {
    const mutationOptions: UseMutationOptions<UpdateMembershipResponse, DefaultError, Options<UpdateMembershipData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateMembership({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteMessageMutation = (options?: Partial<Options<DeleteMessageData>>): UseMutationOptions<DeleteMessageResponse, DefaultError, Options<DeleteMessageData>> => {
    const mutationOptions: UseMutationOptions<DeleteMessageResponse, DefaultError, Options<DeleteMessageData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteMessage({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMessageQueryKey = (options: Options<GetMessageData>) => createQueryKey('getMessage', options);

export const getMessageOptions = (options: Options<GetMessageData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMessage({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMessageQueryKey(options)
    });
};

export const getEffectivePermissionsQueryKey = (options: Options<GetEffectivePermissionsData>) => createQueryKey('getEffectivePermissions', options);

export const getEffectivePermissionsOptions = (options: Options<GetEffectivePermissionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEffectivePermissions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getEffectivePermissionsQueryKey(options)
    });
};

export const listAgentsQueryKey = (options: Options<ListAgentsData>) => createQueryKey('listAgents', options);

export const listAgentsOptions = (options: Options<ListAgentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listAgents({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listAgentsQueryKey(options)
    });
};

export const heartbeatQueryKey = (options: Options<HeartbeatData>) => createQueryKey('heartbeat', options);

export const heartbeatOptions = (options: Options<HeartbeatData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await heartbeat({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: heartbeatQueryKey(options)
    });
};

export const heartbeatMutation = (options?: Partial<Options<HeartbeatData>>): UseMutationOptions<HeartbeatResponse, DefaultError, Options<HeartbeatData>> => {
    const mutationOptions: UseMutationOptions<HeartbeatResponse, DefaultError, Options<HeartbeatData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await heartbeat({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listRolesQueryKey = (options: Options<ListRolesData>) => createQueryKey('listRoles', options);

export const listRolesOptions = (options: Options<ListRolesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listRoles({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listRolesQueryKey(options)
    });
};

export const createRoleQueryKey = (options: Options<CreateRoleData>) => createQueryKey('createRole', options);

export const createRoleOptions = (options: Options<CreateRoleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createRole({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createRoleQueryKey(options)
    });
};

export const createRoleMutation = (options?: Partial<Options<CreateRoleData>>): UseMutationOptions<CreateRoleResponse, DefaultError, Options<CreateRoleData>> => {
    const mutationOptions: UseMutationOptions<CreateRoleResponse, DefaultError, Options<CreateRoleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createRole({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteRoleMutation = (options?: Partial<Options<DeleteRoleData>>): UseMutationOptions<DeleteRoleResponse, DefaultError, Options<DeleteRoleData>> => {
    const mutationOptions: UseMutationOptions<DeleteRoleResponse, DefaultError, Options<DeleteRoleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteRole({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRoleQueryKey = (options: Options<GetRoleData>) => createQueryKey('getRole', options);

export const getRoleOptions = (options: Options<GetRoleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRole({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRoleQueryKey(options)
    });
};

export const updateRoleMutation = (options?: Partial<Options<UpdateRoleData>>): UseMutationOptions<UpdateRoleResponse, DefaultError, Options<UpdateRoleData>> => {
    const mutationOptions: UseMutationOptions<UpdateRoleResponse, DefaultError, Options<UpdateRoleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateRole({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const assignRoleQueryKey = (options: Options<AssignRoleData>) => createQueryKey('assignRole', options);

export const assignRoleOptions = (options: Options<AssignRoleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await assignRole({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: assignRoleQueryKey(options)
    });
};

export const assignRoleMutation = (options?: Partial<Options<AssignRoleData>>): UseMutationOptions<AssignRoleResponse, DefaultError, Options<AssignRoleData>> => {
    const mutationOptions: UseMutationOptions<AssignRoleResponse, DefaultError, Options<AssignRoleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await assignRole({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const revokeRoleQueryKey = (options: Options<RevokeRoleData>) => createQueryKey('revokeRole', options);

export const revokeRoleOptions = (options: Options<RevokeRoleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await revokeRole({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: revokeRoleQueryKey(options)
    });
};

export const revokeRoleMutation = (options?: Partial<Options<RevokeRoleData>>): UseMutationOptions<RevokeRoleResponse, DefaultError, Options<RevokeRoleData>> => {
    const mutationOptions: UseMutationOptions<RevokeRoleResponse, DefaultError, Options<RevokeRoleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await revokeRole({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listRulesQueryKey = (options: Options<ListRulesData>) => createQueryKey('listRules', options);

export const listRulesOptions = (options: Options<ListRulesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listRules({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listRulesQueryKey(options)
    });
};

export const createRuleQueryKey = (options: Options<CreateRuleData>) => createQueryKey('createRule', options);

export const createRuleOptions = (options: Options<CreateRuleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createRule({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createRuleQueryKey(options)
    });
};

export const createRuleMutation = (options?: Partial<Options<CreateRuleData>>): UseMutationOptions<CreateRuleResponse, DefaultError, Options<CreateRuleData>> => {
    const mutationOptions: UseMutationOptions<CreateRuleResponse, DefaultError, Options<CreateRuleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createRule({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteRuleMutation = (options?: Partial<Options<DeleteRuleData>>): UseMutationOptions<DeleteRuleResponse, DefaultError, Options<DeleteRuleData>> => {
    const mutationOptions: UseMutationOptions<DeleteRuleResponse, DefaultError, Options<DeleteRuleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteRule({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updateRuleMutation = (options?: Partial<Options<UpdateRuleData>>): UseMutationOptions<UpdateRuleResponse, DefaultError, Options<UpdateRuleData>> => {
    const mutationOptions: UseMutationOptions<UpdateRuleResponse, DefaultError, Options<UpdateRuleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateRule({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const workloadQueryKey = (options: Options<WorkloadData>) => createQueryKey('workload', options);

export const workloadOptions = (options: Options<WorkloadData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await workload({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: workloadQueryKey(options)
    });
};

export const getAllOrganizationSettingsQueryKey = (options: Options<GetAllOrganizationSettingsData>) => createQueryKey('getAllOrganizationSettings', options);

export const getAllOrganizationSettingsOptions = (options: Options<GetAllOrganizationSettingsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllOrganizationSettings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllOrganizationSettingsQueryKey(options)
    });
};

export const setOrganizationSettingQueryKey = (options: Options<SetOrganizationSettingData>) => createQueryKey('setOrganizationSetting', options);

export const setOrganizationSettingOptions = (options: Options<SetOrganizationSettingData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await setOrganizationSetting({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: setOrganizationSettingQueryKey(options)
    });
};

export const setOrganizationSettingMutation = (options?: Partial<Options<SetOrganizationSettingData>>): UseMutationOptions<SetOrganizationSettingResponse, DefaultError, Options<SetOrganizationSettingData>> => {
    const mutationOptions: UseMutationOptions<SetOrganizationSettingResponse, DefaultError, Options<SetOrganizationSettingData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await setOrganizationSetting({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteOrganizationSettingMutation = (options?: Partial<Options<DeleteOrganizationSettingData>>): UseMutationOptions<DeleteOrganizationSettingResponse, DefaultError, Options<DeleteOrganizationSettingData>> => {
    const mutationOptions: UseMutationOptions<DeleteOrganizationSettingResponse, DefaultError, Options<DeleteOrganizationSettingData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteOrganizationSetting({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getOrganizationSettingQueryKey = (options: Options<GetOrganizationSettingData>) => createQueryKey('getOrganizationSetting', options);

export const getOrganizationSettingOptions = (options: Options<GetOrganizationSettingData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getOrganizationSetting({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOrganizationSettingQueryKey(options)
    });
};

export const checkBreachesQueryKey = (options: Options<CheckBreachesData>) => createQueryKey('checkBreaches', options);

export const checkBreachesOptions = (options: Options<CheckBreachesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await checkBreaches({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: checkBreachesQueryKey(options)
    });
};

export const checkBreachesMutation = (options?: Partial<Options<CheckBreachesData>>): UseMutationOptions<CheckBreachesResponse, DefaultError, Options<CheckBreachesData>> => {
    const mutationOptions: UseMutationOptions<CheckBreachesResponse, DefaultError, Options<CheckBreachesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await checkBreaches({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listPoliciesQueryKey = (options: Options<ListPoliciesData>) => createQueryKey('listPolicies', options);

export const listPoliciesOptions = (options: Options<ListPoliciesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listPolicies({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listPoliciesQueryKey(options)
    });
};

export const createPolicyQueryKey = (options: Options<CreatePolicyData>) => createQueryKey('createPolicy', options);

export const createPolicyOptions = (options: Options<CreatePolicyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createPolicy({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createPolicyQueryKey(options)
    });
};

export const createPolicyMutation = (options?: Partial<Options<CreatePolicyData>>): UseMutationOptions<CreatePolicyResponse, DefaultError, Options<CreatePolicyData>> => {
    const mutationOptions: UseMutationOptions<CreatePolicyResponse, DefaultError, Options<CreatePolicyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createPolicy({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updatePolicyMutation = (options?: Partial<Options<UpdatePolicyData>>): UseMutationOptions<UpdatePolicyResponse, DefaultError, Options<UpdatePolicyData>> => {
    const mutationOptions: UseMutationOptions<UpdatePolicyResponse, DefaultError, Options<UpdatePolicyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updatePolicy({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listSurveysQueryKey = (options: Options<ListSurveysData>) => createQueryKey('listSurveys', options);

export const listSurveysOptions = (options: Options<ListSurveysData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listSurveys({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listSurveysQueryKey(options)
    });
};

export const listSurveysInfiniteQueryKey = (options: Options<ListSurveysData>): QueryKey<Options<ListSurveysData>> => createQueryKey('listSurveys', options, true);

export const listSurveysInfiniteOptions = (options: Options<ListSurveysData>) => {
    return infiniteQueryOptions<ListSurveysResponse, DefaultError, InfiniteData<ListSurveysResponse>, QueryKey<Options<ListSurveysData>>, number | Pick<QueryKey<Options<ListSurveysData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListSurveysData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listSurveys({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listSurveysInfiniteQueryKey(options)
    });
};

export const submitSurveyQueryKey = (options: Options<SubmitSurveyData>) => createQueryKey('submitSurvey', options);

export const submitSurveyOptions = (options: Options<SubmitSurveyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await submitSurvey({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: submitSurveyQueryKey(options)
    });
};

export const submitSurveyMutation = (options?: Partial<Options<SubmitSurveyData>>): UseMutationOptions<SubmitSurveyResponse, DefaultError, Options<SubmitSurveyData>> => {
    const mutationOptions: UseMutationOptions<SubmitSurveyResponse, DefaultError, Options<SubmitSurveyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await submitSurvey({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSurveyAnalyticsQueryKey = (options: Options<GetSurveyAnalyticsData>) => createQueryKey('getSurveyAnalytics', options);

export const getSurveyAnalyticsOptions = (options: Options<GetSurveyAnalyticsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSurveyAnalytics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSurveyAnalyticsQueryKey(options)
    });
};

export const exportSurveysQueryKey = (options: Options<ExportSurveysData>) => createQueryKey('exportSurveys', options);

export const exportSurveysOptions = (options: Options<ExportSurveysData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await exportSurveys({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: exportSurveysQueryKey(options)
    });
};

export const exportSurveysInfiniteQueryKey = (options: Options<ExportSurveysData>): QueryKey<Options<ExportSurveysData>> => createQueryKey('exportSurveys', options, true);

export const exportSurveysInfiniteOptions = (options: Options<ExportSurveysData>) => {
    return infiniteQueryOptions<ExportSurveysResponse, DefaultError, InfiniteData<ExportSurveysResponse>, QueryKey<Options<ExportSurveysData>>, number | Pick<QueryKey<Options<ExportSurveysData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ExportSurveysData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await exportSurveys({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: exportSurveysInfiniteQueryKey(options)
    });
};

export const deleteSurveyMutation = (options?: Partial<Options<DeleteSurveyData>>): UseMutationOptions<unknown, DefaultError, Options<DeleteSurveyData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DeleteSurveyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteSurvey({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSurveyQueryKey = (options: Options<GetSurveyData>) => createQueryKey('getSurvey', options);

export const getSurveyOptions = (options: Options<GetSurveyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSurvey({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSurveyQueryKey(options)
    });
};

export const updateSurveyMutation = (options?: Partial<Options<UpdateSurveyData>>): UseMutationOptions<UpdateSurveyResponse, DefaultError, Options<UpdateSurveyData>> => {
    const mutationOptions: UseMutationOptions<UpdateSurveyResponse, DefaultError, Options<UpdateSurveyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateSurvey({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listTagsQueryKey = (options: Options<ListTagsData>) => createQueryKey('listTags', options);

export const listTagsOptions = (options: Options<ListTagsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listTags({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTagsQueryKey(options)
    });
};

export const listTagsInfiniteQueryKey = (options: Options<ListTagsData>): QueryKey<Options<ListTagsData>> => createQueryKey('listTags', options, true);

export const listTagsInfiniteOptions = (options: Options<ListTagsData>) => {
    return infiniteQueryOptions<ListTagsResponse, DefaultError, InfiniteData<ListTagsResponse>, QueryKey<Options<ListTagsData>>, number | Pick<QueryKey<Options<ListTagsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListTagsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listTags({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTagsInfiniteQueryKey(options)
    });
};

export const createTagQueryKey = (options: Options<CreateTagData>) => createQueryKey('createTag', options);

/**
 * Create a tag
 * Requires permission: MANAGE_TAGS
 */
export const createTagOptions = (options: Options<CreateTagData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createTag({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createTagQueryKey(options)
    });
};

/**
 * Create a tag
 * Requires permission: MANAGE_TAGS
 */
export const createTagMutation = (options?: Partial<Options<CreateTagData>>): UseMutationOptions<CreateTagResponse, DefaultError, Options<CreateTagData>> => {
    const mutationOptions: UseMutationOptions<CreateTagResponse, DefaultError, Options<CreateTagData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createTag({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPopularTagsQueryKey = (options: Options<GetPopularTagsData>) => createQueryKey('getPopularTags', options);

export const getPopularTagsOptions = (options: Options<GetPopularTagsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPopularTags({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPopularTagsQueryKey(options)
    });
};

/**
 * Delete a tag
 * Requires permission: MANAGE_TAGS
 */
export const deleteTagMutation = (options?: Partial<Options<DeleteTagData>>): UseMutationOptions<DeleteTagResponse, DefaultError, Options<DeleteTagData>> => {
    const mutationOptions: UseMutationOptions<DeleteTagResponse, DefaultError, Options<DeleteTagData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteTag({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTagQueryKey = (options: Options<GetTagData>) => createQueryKey('getTag', options);

export const getTagOptions = (options: Options<GetTagData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTag({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTagQueryKey(options)
    });
};

/**
 * Update a tag
 * Requires permission: MANAGE_TAGS
 */
export const updateTagMutation = (options?: Partial<Options<UpdateTagData>>): UseMutationOptions<UpdateTagResponse, DefaultError, Options<UpdateTagData>> => {
    const mutationOptions: UseMutationOptions<UpdateTagResponse, DefaultError, Options<UpdateTagData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateTag({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTagWithTicketsQueryKey = (options: Options<GetTagWithTicketsData>) => createQueryKey('getTagWithTickets', options);

export const getTagWithTicketsOptions = (options: Options<GetTagWithTicketsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTagWithTickets({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTagWithTicketsQueryKey(options)
    });
};

export const getTagWithTicketsInfiniteQueryKey = (options: Options<GetTagWithTicketsData>): QueryKey<Options<GetTagWithTicketsData>> => createQueryKey('getTagWithTickets', options, true);

export const getTagWithTicketsInfiniteOptions = (options: Options<GetTagWithTicketsData>) => {
    return infiniteQueryOptions<GetTagWithTicketsResponse, DefaultError, InfiniteData<GetTagWithTicketsResponse>, QueryKey<Options<GetTagWithTicketsData>>, number | Pick<QueryKey<Options<GetTagWithTicketsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetTagWithTicketsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getTagWithTickets({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTagWithTicketsInfiniteQueryKey(options)
    });
};

export const listTicketsQueryKey = (options: Options<ListTicketsData>) => createQueryKey('listTickets', options);

/**
 * List tickets with filtering
 * Retrieves a paginated list of tickets with optional filtering by status, priority, assignment, creator, and tags. Results are ordered by creation date (newest first).
 */
export const listTicketsOptions = (options: Options<ListTicketsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listTickets({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTicketsQueryKey(options)
    });
};

export const listTicketsInfiniteQueryKey = (options: Options<ListTicketsData>): QueryKey<Options<ListTicketsData>> => createQueryKey('listTickets', options, true);

/**
 * List tickets with filtering
 * Retrieves a paginated list of tickets with optional filtering by status, priority, assignment, creator, and tags. Results are ordered by creation date (newest first).
 */
export const listTicketsInfiniteOptions = (options: Options<ListTicketsData>) => {
    return infiniteQueryOptions<ListTicketsResponse, DefaultError, InfiniteData<ListTicketsResponse>, QueryKey<Options<ListTicketsData>>, number | Pick<QueryKey<Options<ListTicketsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListTicketsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listTickets({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTicketsInfiniteQueryKey(options)
    });
};

export const createTicketQueryKey = (options: Options<CreateTicketData>) => createQueryKey('createTicket', options);

/**
 * Create a new support ticket
 * Creates a new support ticket in the specified organization. The ticket will be assigned to the authenticated user as the creator and can optionally be assigned to another team member.
 */
export const createTicketOptions = (options: Options<CreateTicketData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createTicket({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createTicketQueryKey(options)
    });
};

/**
 * Create a new support ticket
 * Creates a new support ticket in the specified organization. The ticket will be assigned to the authenticated user as the creator and can optionally be assigned to another team member.
 */
export const createTicketMutation = (options?: Partial<Options<CreateTicketData>>): UseMutationOptions<CreateTicketResponse, DefaultError, Options<CreateTicketData>> => {
    const mutationOptions: UseMutationOptions<CreateTicketResponse, DefaultError, Options<CreateTicketData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createTicket({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const bulkUpdateTicketsQueryKey = (options: Options<BulkUpdateTicketsData>) => createQueryKey('bulkUpdateTickets', options);

/**
 * Bulk update tickets
 */
export const bulkUpdateTicketsOptions = (options: Options<BulkUpdateTicketsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await bulkUpdateTickets({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: bulkUpdateTicketsQueryKey(options)
    });
};

/**
 * Bulk update tickets
 */
export const bulkUpdateTicketsMutation = (options?: Partial<Options<BulkUpdateTicketsData>>): UseMutationOptions<unknown, DefaultError, Options<BulkUpdateTicketsData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<BulkUpdateTicketsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await bulkUpdateTickets({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const mergeTicketsQueryKey = (options: Options<MergeTicketsData>) => createQueryKey('mergeTickets', options);

/**
 * Merge two tickets
 */
export const mergeTicketsOptions = (options: Options<MergeTicketsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await mergeTickets({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: mergeTicketsQueryKey(options)
    });
};

/**
 * Merge two tickets
 */
export const mergeTicketsMutation = (options?: Partial<Options<MergeTicketsData>>): UseMutationOptions<unknown, DefaultError, Options<MergeTicketsData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<MergeTicketsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await mergeTickets({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listSavedViewsQueryKey = (options: Options<ListSavedViewsData>) => createQueryKey('listSavedViews', options);

/**
 * List saved views
 */
export const listSavedViewsOptions = (options: Options<ListSavedViewsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listSavedViews({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listSavedViewsQueryKey(options)
    });
};

export const createSavedViewQueryKey = (options: Options<CreateSavedViewData>) => createQueryKey('createSavedView', options);

/**
 * Create a saved view
 */
export const createSavedViewOptions = (options: Options<CreateSavedViewData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createSavedView({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createSavedViewQueryKey(options)
    });
};

/**
 * Create a saved view
 */
export const createSavedViewMutation = (options?: Partial<Options<CreateSavedViewData>>): UseMutationOptions<CreateSavedViewResponse, DefaultError, Options<CreateSavedViewData>> => {
    const mutationOptions: UseMutationOptions<CreateSavedViewResponse, DefaultError, Options<CreateSavedViewData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createSavedView({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteTicketMutation = (options?: Partial<Options<DeleteTicketData>>): UseMutationOptions<DeleteTicketResponse, DefaultError, Options<DeleteTicketData>> => {
    const mutationOptions: UseMutationOptions<DeleteTicketResponse, DefaultError, Options<DeleteTicketData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteTicket({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTicketQueryKey = (options: Options<GetTicketData>) => createQueryKey('getTicket', options);

/**
 * Get ticket details
 * Retrieves detailed information about a specific ticket including its current status, assignment, tags, and metadata.
 */
export const getTicketOptions = (options: Options<GetTicketData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTicket({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTicketQueryKey(options)
    });
};

export const updateTicketMutation = (options?: Partial<Options<UpdateTicketData>>): UseMutationOptions<UpdateTicketResponse, DefaultError, Options<UpdateTicketData>> => {
    const mutationOptions: UseMutationOptions<UpdateTicketResponse, DefaultError, Options<UpdateTicketData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateTicket({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete current user's draft for a ticket
 */
export const deleteDraftMutation = (options?: Partial<Options<DeleteDraftData>>): UseMutationOptions<DeleteDraftResponse, DefaultError, Options<DeleteDraftData>> => {
    const mutationOptions: UseMutationOptions<DeleteDraftResponse, DefaultError, Options<DeleteDraftData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteDraft({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDraftQueryKey = (options: Options<GetDraftData>) => createQueryKey('getDraft', options);

/**
 * Get current user's draft for a ticket
 */
export const getDraftOptions = (options: Options<GetDraftData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDraft({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDraftQueryKey(options)
    });
};

export const upsertDraftQueryKey = (options: Options<UpsertDraftData>) => createQueryKey('upsertDraft', options);

/**
 * Create or update a draft for a ticket
 */
export const upsertDraftOptions = (options: Options<UpsertDraftData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await upsertDraft({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: upsertDraftQueryKey(options)
    });
};

/**
 * Create or update a draft for a ticket
 */
export const upsertDraftMutation = (options?: Partial<Options<UpsertDraftData>>): UseMutationOptions<UpsertDraftResponse, DefaultError, Options<UpsertDraftData>> => {
    const mutationOptions: UseMutationOptions<UpsertDraftResponse, DefaultError, Options<UpsertDraftData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await upsertDraft({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTicketHistoryQueryKey = (options: Options<GetTicketHistoryData>) => createQueryKey('getTicketHistory', options);

/**
 * Get ticket history
 * Requires permission: VIEW_ALL_TICKETS
 */
export const getTicketHistoryOptions = (options: Options<GetTicketHistoryData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTicketHistory({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTicketHistoryQueryKey(options)
    });
};

export const releaseTicketLockMutation = (options?: Partial<Options<ReleaseTicketLockData>>): UseMutationOptions<ReleaseTicketLockResponse, DefaultError, Options<ReleaseTicketLockData>> => {
    const mutationOptions: UseMutationOptions<ReleaseTicketLockResponse, DefaultError, Options<ReleaseTicketLockData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await releaseTicketLock({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const lockTicketQueryKey = (options: Options<LockTicketData>) => createQueryKey('lockTicket', options);

export const lockTicketOptions = (options: Options<LockTicketData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await lockTicket({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lockTicketQueryKey(options)
    });
};

export const lockTicketMutation = (options?: Partial<Options<LockTicketData>>): UseMutationOptions<unknown, DefaultError, Options<LockTicketData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<LockTicketData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await lockTicket({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const takeoverTicketLockQueryKey = (options: Options<TakeoverTicketLockData>) => createQueryKey('takeoverTicketLock', options);

export const takeoverTicketLockOptions = (options: Options<TakeoverTicketLockData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await takeoverTicketLock({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: takeoverTicketLockQueryKey(options)
    });
};

export const takeoverTicketLockMutation = (options?: Partial<Options<TakeoverTicketLockData>>): UseMutationOptions<unknown, DefaultError, Options<TakeoverTicketLockData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<TakeoverTicketLockData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await takeoverTicketLock({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listTicketMessagesQueryKey = (options: Options<ListTicketMessagesData>) => createQueryKey('listTicketMessages', options);

export const listTicketMessagesOptions = (options: Options<ListTicketMessagesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listTicketMessages({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTicketMessagesQueryKey(options)
    });
};

export const listTicketMessagesInfiniteQueryKey = (options: Options<ListTicketMessagesData>): QueryKey<Options<ListTicketMessagesData>> => createQueryKey('listTicketMessages', options, true);

export const listTicketMessagesInfiniteOptions = (options: Options<ListTicketMessagesData>) => {
    return infiniteQueryOptions<ListTicketMessagesResponse, DefaultError, InfiniteData<ListTicketMessagesResponse>, QueryKey<Options<ListTicketMessagesData>>, number | Pick<QueryKey<Options<ListTicketMessagesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListTicketMessagesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listTicketMessages({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTicketMessagesInfiniteQueryKey(options)
    });
};

export const createMessageQueryKey = (options: Options<CreateMessageData>) => createQueryKey('createMessage', options);

export const createMessageOptions = (options: Options<CreateMessageData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createMessage({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createMessageQueryKey(options)
    });
};

export const createMessageMutation = (options?: Partial<Options<CreateMessageData>>): UseMutationOptions<CreateMessageResponse, DefaultError, Options<CreateMessageData>> => {
    const mutationOptions: UseMutationOptions<CreateMessageResponse, DefaultError, Options<CreateMessageData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createMessage({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMessageCountQueryKey = (options: Options<GetMessageCountData>) => createQueryKey('getMessageCount', options);

export const getMessageCountOptions = (options: Options<GetMessageCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMessageCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMessageCountQueryKey(options)
    });
};

export const getLatestMessageQueryKey = (options: Options<GetLatestMessageData>) => createQueryKey('getLatestMessage', options);

export const getLatestMessageOptions = (options: Options<GetLatestMessageData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLatestMessage({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLatestMessageQueryKey(options)
    });
};

export const searchMessagesQueryKey = (options: Options<SearchMessagesData>) => createQueryKey('searchMessages', options);

export const searchMessagesOptions = (options: Options<SearchMessagesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await searchMessages({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: searchMessagesQueryKey(options)
    });
};

export const searchMessagesInfiniteQueryKey = (options: Options<SearchMessagesData>): QueryKey<Options<SearchMessagesData>> => createQueryKey('searchMessages', options, true);

export const searchMessagesInfiniteOptions = (options: Options<SearchMessagesData>) => {
    return infiniteQueryOptions<SearchMessagesResponse, DefaultError, InfiniteData<SearchMessagesResponse>, QueryKey<Options<SearchMessagesData>>, number | Pick<QueryKey<Options<SearchMessagesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<SearchMessagesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await searchMessages({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: searchMessagesInfiniteQueryKey(options)
    });
};

export const listMessageAttachmentsQueryKey = (options: Options<ListMessageAttachmentsData>) => createQueryKey('listMessageAttachments', options);

export const listMessageAttachmentsOptions = (options: Options<ListMessageAttachmentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listMessageAttachments({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listMessageAttachmentsQueryKey(options)
    });
};

export const uploadAttachmentsQueryKey = (options: Options<UploadAttachmentsData>) => createQueryKey('uploadAttachments', options);

export const uploadAttachmentsOptions = (options: Options<UploadAttachmentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await uploadAttachments({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: uploadAttachmentsQueryKey(options)
    });
};

export const uploadAttachmentsMutation = (options?: Partial<Options<UploadAttachmentsData>>): UseMutationOptions<UploadAttachmentsResponse, DefaultError, Options<UploadAttachmentsData>> => {
    const mutationOptions: UseMutationOptions<UploadAttachmentsResponse, DefaultError, Options<UploadAttachmentsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await uploadAttachments({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteAttachmentMutation = (options?: Partial<Options<DeleteAttachmentData>>): UseMutationOptions<DeleteAttachmentResponse, DefaultError, Options<DeleteAttachmentData>> => {
    const mutationOptions: UseMutationOptions<DeleteAttachmentResponse, DefaultError, Options<DeleteAttachmentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteAttachment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const removeTagsFromTicketMutation = (options?: Partial<Options<RemoveTagsFromTicketData>>): UseMutationOptions<unknown, DefaultError, Options<RemoveTagsFromTicketData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<RemoveTagsFromTicketData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeTagsFromTicket({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const addTagsToTicketQueryKey = (options: Options<AddTagsToTicketData>) => createQueryKey('addTagsToTicket', options);

export const addTagsToTicketOptions = (options: Options<AddTagsToTicketData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await addTagsToTicket({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: addTagsToTicketQueryKey(options)
    });
};

export const addTagsToTicketMutation = (options?: Partial<Options<AddTagsToTicketData>>): UseMutationOptions<unknown, DefaultError, Options<AddTagsToTicketData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<AddTagsToTicketData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await addTagsToTicket({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listTypingQueryKey = (options: Options<ListTypingData>) => createQueryKey('listTyping', options);

export const listTypingOptions = (options: Options<ListTypingData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listTyping({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTypingQueryKey(options)
    });
};

export const typingUpdateQueryKey = (options: Options<TypingUpdateData>) => createQueryKey('typingUpdate', options);

export const typingUpdateOptions = (options: Options<TypingUpdateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await typingUpdate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: typingUpdateQueryKey(options)
    });
};

export const typingUpdateMutation = (options?: Partial<Options<TypingUpdateData>>): UseMutationOptions<TypingUpdateResponse, DefaultError, Options<TypingUpdateData>> => {
    const mutationOptions: UseMutationOptions<TypingUpdateResponse, DefaultError, Options<TypingUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await typingUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listWebhooksQueryKey = (options: Options<ListWebhooksData>) => createQueryKey('listWebhooks', options);

export const listWebhooksOptions = (options: Options<ListWebhooksData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listWebhooks({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listWebhooksQueryKey(options)
    });
};

export const listWebhooksInfiniteQueryKey = (options: Options<ListWebhooksData>): QueryKey<Options<ListWebhooksData>> => createQueryKey('listWebhooks', options, true);

export const listWebhooksInfiniteOptions = (options: Options<ListWebhooksData>) => {
    return infiniteQueryOptions<ListWebhooksResponse, DefaultError, InfiniteData<ListWebhooksResponse>, QueryKey<Options<ListWebhooksData>>, number | Pick<QueryKey<Options<ListWebhooksData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListWebhooksData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listWebhooks({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listWebhooksInfiniteQueryKey(options)
    });
};

export const createWebhookQueryKey = (options: Options<CreateWebhookData>) => createQueryKey('createWebhook', options);

export const createWebhookOptions = (options: Options<CreateWebhookData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createWebhook({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createWebhookQueryKey(options)
    });
};

export const createWebhookMutation = (options?: Partial<Options<CreateWebhookData>>): UseMutationOptions<CreateWebhookResponse, DefaultError, Options<CreateWebhookData>> => {
    const mutationOptions: UseMutationOptions<CreateWebhookResponse, DefaultError, Options<CreateWebhookData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createWebhook({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listWebhookEventsQueryKey = (options: Options<ListWebhookEventsData>) => createQueryKey('listWebhookEvents', options);

export const listWebhookEventsOptions = (options: Options<ListWebhookEventsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listWebhookEvents({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listWebhookEventsQueryKey(options)
    });
};

export const sendWebhooksQueryKey = (options: Options<SendWebhooksData>) => createQueryKey('sendWebhooks', options);

export const sendWebhooksOptions = (options: Options<SendWebhooksData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await sendWebhooks({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: sendWebhooksQueryKey(options)
    });
};

export const sendWebhooksMutation = (options?: Partial<Options<SendWebhooksData>>): UseMutationOptions<SendWebhooksResponse, DefaultError, Options<SendWebhooksData>> => {
    const mutationOptions: UseMutationOptions<SendWebhooksResponse, DefaultError, Options<SendWebhooksData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await sendWebhooks({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWebhookStatsQueryKey = (options: Options<GetWebhookStatsData>) => createQueryKey('getWebhookStats', options);

export const getWebhookStatsOptions = (options: Options<GetWebhookStatsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWebhookStats({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWebhookStatsQueryKey(options)
    });
};

export const deleteWebhookMutation = (options?: Partial<Options<DeleteWebhookData>>): UseMutationOptions<unknown, DefaultError, Options<DeleteWebhookData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DeleteWebhookData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteWebhook({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWebhookQueryKey = (options: Options<GetWebhookData>) => createQueryKey('getWebhook', options);

export const getWebhookOptions = (options: Options<GetWebhookData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWebhook({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWebhookQueryKey(options)
    });
};

export const updateWebhookMutation = (options?: Partial<Options<UpdateWebhookData>>): UseMutationOptions<UpdateWebhookResponse, DefaultError, Options<UpdateWebhookData>> => {
    const mutationOptions: UseMutationOptions<UpdateWebhookResponse, DefaultError, Options<UpdateWebhookData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateWebhook({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const testWebhookQueryKey = (options: Options<TestWebhookData>) => createQueryKey('testWebhook', options);

export const testWebhookOptions = (options: Options<TestWebhookData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await testWebhook({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: testWebhookQueryKey(options)
    });
};

export const testWebhookMutation = (options?: Partial<Options<TestWebhookData>>): UseMutationOptions<TestWebhookResponse, DefaultError, Options<TestWebhookData>> => {
    const mutationOptions: UseMutationOptions<TestWebhookResponse, DefaultError, Options<TestWebhookData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await testWebhook({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPermissionsCatalogQueryKey = (options?: Options<GetPermissionsCatalogData>) => createQueryKey('getPermissionsCatalog', options);

export const getPermissionsCatalogOptions = (options?: Options<GetPermissionsCatalogData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPermissionsCatalog({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPermissionsCatalogQueryKey(options)
    });
};

export const listSessionsQueryKey = (options?: Options<ListSessionsData>) => createQueryKey('listSessions', options);

export const listSessionsOptions = (options?: Options<ListSessionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listSessions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listSessionsQueryKey(options)
    });
};

export const cleanupExpiredSessionsQueryKey = (options?: Options<CleanupExpiredSessionsData>) => createQueryKey('cleanupExpiredSessions', options);

export const cleanupExpiredSessionsOptions = (options?: Options<CleanupExpiredSessionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await cleanupExpiredSessions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: cleanupExpiredSessionsQueryKey(options)
    });
};

export const cleanupExpiredSessionsMutation = (options?: Partial<Options<CleanupExpiredSessionsData>>): UseMutationOptions<unknown, DefaultError, Options<CleanupExpiredSessionsData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<CleanupExpiredSessionsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await cleanupExpiredSessions({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const revokeAllSessionsQueryKey = (options: Options<RevokeAllSessionsData>) => createQueryKey('revokeAllSessions', options);

export const revokeAllSessionsOptions = (options: Options<RevokeAllSessionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await revokeAllSessions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: revokeAllSessionsQueryKey(options)
    });
};

export const revokeAllSessionsMutation = (options?: Partial<Options<RevokeAllSessionsData>>): UseMutationOptions<unknown, DefaultError, Options<RevokeAllSessionsData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<RevokeAllSessionsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await revokeAllSessions({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSessionStatsQueryKey = (options?: Options<GetSessionStatsData>) => createQueryKey('getSessionStats', options);

export const getSessionStatsOptions = (options?: Options<GetSessionStatsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSessionStats({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSessionStatsQueryKey(options)
    });
};

export const revokeSessionMutation = (options?: Partial<Options<RevokeSessionData>>): UseMutationOptions<unknown, DefaultError, Options<RevokeSessionData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<RevokeSessionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await revokeSession({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSessionQueryKey = (options: Options<GetSessionData>) => createQueryKey('getSession', options);

export const getSessionOptions = (options: Options<GetSessionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSession({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSessionQueryKey(options)
    });
};

export const extendSessionQueryKey = (options: Options<ExtendSessionData>) => createQueryKey('extendSession', options);

export const extendSessionOptions = (options: Options<ExtendSessionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await extendSession({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: extendSessionQueryKey(options)
    });
};

export const extendSessionMutation = (options?: Partial<Options<ExtendSessionData>>): UseMutationOptions<ExtendSessionResponse, DefaultError, Options<ExtendSessionData>> => {
    const mutationOptions: UseMutationOptions<ExtendSessionResponse, DefaultError, Options<ExtendSessionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await extendSession({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteAccountMutation = (options?: Partial<Options<DeleteAccountData>>): UseMutationOptions<DeleteAccountResponse, DefaultError, Options<DeleteAccountData>> => {
    const mutationOptions: UseMutationOptions<DeleteAccountResponse, DefaultError, Options<DeleteAccountData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteAccount({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listApiKeysQueryKey = (options?: Options<ListApiKeysData>) => createQueryKey('listApiKeys', options);

export const listApiKeysOptions = (options?: Options<ListApiKeysData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listApiKeys({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listApiKeysQueryKey(options)
    });
};

export const listApiKeysInfiniteQueryKey = (options?: Options<ListApiKeysData>): QueryKey<Options<ListApiKeysData>> => createQueryKey('listApiKeys', options, true);

export const listApiKeysInfiniteOptions = (options?: Options<ListApiKeysData>) => {
    return infiniteQueryOptions<ListApiKeysResponse, DefaultError, InfiniteData<ListApiKeysResponse>, QueryKey<Options<ListApiKeysData>>, number | Pick<QueryKey<Options<ListApiKeysData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListApiKeysData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listApiKeys({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listApiKeysInfiniteQueryKey(options)
    });
};

export const createApiKeyQueryKey = (options: Options<CreateApiKeyData>) => createQueryKey('createApiKey', options);

export const createApiKeyOptions = (options: Options<CreateApiKeyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createApiKey({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createApiKeyQueryKey(options)
    });
};

export const createApiKeyMutation = (options?: Partial<Options<CreateApiKeyData>>): UseMutationOptions<CreateApiKeyResponse2, DefaultError, Options<CreateApiKeyData>> => {
    const mutationOptions: UseMutationOptions<CreateApiKeyResponse2, DefaultError, Options<CreateApiKeyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createApiKey({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteApiKeyMutation = (options?: Partial<Options<DeleteApiKeyData>>): UseMutationOptions<DeleteApiKeyResponse, DefaultError, Options<DeleteApiKeyData>> => {
    const mutationOptions: UseMutationOptions<DeleteApiKeyResponse, DefaultError, Options<DeleteApiKeyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteApiKey({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiKeyQueryKey = (options: Options<GetApiKeyData>) => createQueryKey('getApiKey', options);

export const getApiKeyOptions = (options: Options<GetApiKeyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiKey({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiKeyQueryKey(options)
    });
};

export const revokeApiKeyQueryKey = (options: Options<RevokeApiKeyData>) => createQueryKey('revokeApiKey', options);

export const revokeApiKeyOptions = (options: Options<RevokeApiKeyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await revokeApiKey({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: revokeApiKeyQueryKey(options)
    });
};

export const revokeApiKeyMutation = (options?: Partial<Options<RevokeApiKeyData>>): UseMutationOptions<RevokeApiKeyResponse, DefaultError, Options<RevokeApiKeyData>> => {
    const mutationOptions: UseMutationOptions<RevokeApiKeyResponse, DefaultError, Options<RevokeApiKeyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await revokeApiKey({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getLoginAttemptsQueryKey = (options?: Options<GetLoginAttemptsData>) => createQueryKey('getLoginAttempts', options);

export const getLoginAttemptsOptions = (options?: Options<GetLoginAttemptsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLoginAttempts({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLoginAttemptsQueryKey(options)
    });
};

export const getLoginHistoryQueryKey = (options?: Options<GetLoginHistoryData>) => createQueryKey('getLoginHistory', options);

export const getLoginHistoryOptions = (options?: Options<GetLoginHistoryData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLoginHistory({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLoginHistoryQueryKey(options)
    });
};

export const changePasswordMutation = (options?: Partial<Options<ChangePasswordData>>): UseMutationOptions<ChangePasswordResponse, DefaultError, Options<ChangePasswordData>> => {
    const mutationOptions: UseMutationOptions<ChangePasswordResponse, DefaultError, Options<ChangePasswordData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await changePassword({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getProfileQueryKey = (options?: Options<GetProfileData>) => createQueryKey('getProfile', options);

export const getProfileOptions = (options?: Options<GetProfileData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getProfile({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getProfileQueryKey(options)
    });
};

export const updateProfileMutation = (options?: Partial<Options<UpdateProfileData>>): UseMutationOptions<UpdateProfileResponse, DefaultError, Options<UpdateProfileData>> => {
    const mutationOptions: UseMutationOptions<UpdateProfileResponse, DefaultError, Options<UpdateProfileData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateProfile({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};